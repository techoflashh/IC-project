%%manim -ql -v WARNING combined 


class combined(Scene):
    def construct(self):
        myTemplate = TexTemplate()
        myTemplate.add_to_preamble(r"\usepackage{mathrsfs}")
        newTemplate = TexTemplate()
        newTemplate.add_to_preamble(r"\usepackage{amsmath}")
        Topic = Tex("Capacity Theorems For the Relay Channel").scale(1.5)
        self.play(Write(Topic))
        self.play(Topic.animate.to_edge(UL).scale(0.5).shift(LEFT*3.7).set_color(BLUE),run_time = 2)
        self.wait()
        fillColor = BLUE
        boxTextColor = YELLOW
        name = Tex("DMC", color=boxTextColor).scale(0.8)
        box = always_redraw(lambda:SurroundingRectangle(
            name, color=BLACK, fill_opacity=0.5, fill_color=fillColor, buff=0.2))
        sublist = ['1', '2', 'n']
        padx = 1.1
        pady = 0.9
        
        for e in sublist:
            x1 = MathTex(f"x_{e}").next_to(box, LEFT, buff=1.5)
            self.bring_to_back(name)
            self.bring_to_front(box)
            self.bring_to_back(x1)
            joint = Line(color=PURPLE, buff=0.1)
            joint.put_start_and_end_on(x1.get_right(), box.get_left())
            self.bring_to_front(joint)
            tri = Triangle(fill_color=BLUE, fill_opacity=0.75).scale(0.2).rotate(270 * DEGREES).next_to(box, LEFT, buff=padx)
            self.play(tri.animate.shift(RIGHT * padx))
            self.remove(x1)
            self.remove(tri)
            y1 = MathTex(f"y_{e}").next_to(box, RIGHT, buff=1.5)
            self.bring_to_back(y1)
            joint.put_start_and_end_on(y1.get_left(), box.get_right())
            tri = Triangle(fill_color=BLUE, fill_opacity=0.75).scale(0.2).rotate(270 * DEGREES).next_to(box, RIGHT)
            self.play(tri.animate.shift(RIGHT * pady))
            self.remove(y1)
            self.remove(tri)
            self.remove(joint)
            self.remove(name)
            self.remove(box)

        name = MathTex("p(y,y_1|x_1,x_2)", color=boxTextColor).scale(0.8)
        box = always_redraw(lambda:SurroundingRectangle(
            name, color=BLACK, fill_opacity=0.5, fill_color=fillColor, buff=0.2))
        relayEncoder = Tex("Relay Encoder",color=boxTextColor).scale(0.8).next_to(box, UP, buff=1.5)
        boxRelay = always_redraw(lambda: SurroundingRectangle(
            relayEncoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        Encoder = Tex("Encoder", color = boxTextColor).scale(0.8).next_to(box, LEFT,  buff = 2)
        Decoder = Tex("Decoder", color = boxTextColor).scale(0.8).next_to(box, RIGHT, buff = 2)
        EncoderBox = always_redraw(lambda: SurroundingRectangle(
            Encoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        DecoderBox = always_redraw(lambda: SurroundingRectangle(
            Decoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        arrow1 = Arrow(start = box.get_top(), end = boxRelay.get_bottom(), buff = 0.1).shift(LEFT*0.8)
        arrow2 = Arrow(start = boxRelay.get_bottom(), end = box.get_top(), buff = 0.1).shift(RIGHT*0.8)
        arrow3 = Arrow(start= EncoderBox.get_right(), end = box.get_left(), buff = 0.1)
        arrow4 = Arrow(start = box.get_right(), end = DecoderBox.get_left(), buff = 0.1)
        x2 = MathTex("X_2", color = BLUE).scale(0.75).next_to(arrow2, RIGHT)
        y1 = MathTex("Y_1", color = BLUE).scale(0.75).next_to(arrow1, LEFT)
        x1 = MathTex("X_1", color = BLUE).scale(0.75).next_to(arrow3, UP)
        y = MathTex("Y", color = BLUE).scale(0.75).next_to(arrow4, UP)
        W = Tex("W", color = BLUE).scale(0.75).next_to(EncoderBox, LEFT, buff = 1)
        W1 = MathTex("\hat{W}", color = BLUE).scale(0.75).next_to(DecoderBox, RIGHT, buff  = 1)
        arrow5 = Arrow(start = W.get_right(), end = EncoderBox.get_left(), buff = 0.1)
        arrow6 = Arrow(start = DecoderBox.get_right(), end = W1.get_left(), buff = 0.1)
        denotedBy = Tex(r"$(\mathscr{X}_1 \times \mathscr{X}_2 ,p(y,y_1|x_1,x_2),\mathscr{Y} \times \mathscr{Y}_1)$",tex_template = myTemplate).next_to(box,DOWN,buff= 1)
        self.play(Write(W))
        self.play(Write(W1))
        self.play(Create(EncoderBox),Create(Encoder))
        self.play(Create(arrow5))
        self.play(Create(box),Create(name))
        self.play(Create(arrow3),Write(x1))
        self.play(Create(boxRelay),Create(relayEncoder))
        self.play(Create(arrow1),Write(y1))
        self.play(Create(arrow2),Write(x2))
        self.play(Create(DecoderBox),Write(Decoder))
        self.play(Create(arrow4),Write(y))
        self.play(Create(arrow6))
        self.play(FadeIn(denotedBy))
        self.wait()
        self.play(FadeOut(denotedBy,arrow6,arrow4,y,DecoderBox,Decoder,arrow2,x2,arrow1,y1,boxRelay,relayEncoder,arrow3,x1,box,name,arrow5,EncoderBox,Encoder,W1,W))

        text = Tex(r"$\textit{Theorem 1}$: The").to_edge(LEFT, buff = 0.5).shift(UP*2)
        Capacity = Tex("Capacity").next_to(text, RIGHT, buff = 0.2)
        mid = Tex("C of the").next_to(Capacity, RIGHT, buff = 0.2)
        degr = Tex("degraded relay channel").next_to(mid,RIGHT ,buff =0.2)
        Degr = Tex("Degraded Relay Channel").next_to(mid,RIGHT,buff = 0.2)
        penu = Tex("is").next_to(Degr, RIGHT,buff = 0.2)
        last = Tex("given by :").next_to(Capacity, DOWN, buff = 0.2).shift(LEFT*0.5)
        equation = Tex(r" C = $\underset{p(x_1|x_2)}{sup}$ min\{I($X_1$,$X_2$;Y),I($X_1;Y_1|X_2$)\}",tex_template = newTemplate,).next_to(last, DOWN, buff = 0.2).shift(RIGHT*2)
        concluding = Tex("where the supremum is over all the joint distributions p($x_1,x_2$)").next_to(equation, DOWN, buff = 0.2).shift(RIGHT*0.5)
        reallast = Tex(r"on $\mathscr{X}_1$ $\times$ $\mathscr{X}_2$", tex_template=myTemplate,).next_to(concluding, DOWN, buff = 0.2)
        self.play(Write(text), Write(Capacity), Write(mid), Write(degr), Write(penu), Write(last), Write(equation), Write(concluding), Write(reallast))
        self.play(FadeOut(degr),FadeIn(Degr),Capacity.animate.set_color(YELLOW),Degr.animate.set_color(YELLOW), run_time = 2)
        self.play(FadeOut(text, mid, penu, last, equation, concluding, reallast), run_time = 1)
        self.play(Capacity.animate.shift(LEFT*2.5))
        self.play(FadeOut(Degr))
        Error =  Tex("Error", color = ORANGE).next_to(Capacity, DOWN, buff = 0.2)
        DefineError = Tex(r"If a message w $\epsilon$ [1,M] is sent, let g() be the decoding function,").next_to(Error, DOWN, buff = 0.2).shift(RIGHT*4.5)
        Erroreqn = Tex(r"$\lambda$(w) = Pr\{g(Y) $\neq$ w\}").next_to(DefineError, DOWN, buff = 0.2)
        Cond = Tex("denote the conditional probability of error.").next_to(Erroreqn, DOWN, buff = 0.2)
        self.play(Write(Error), Write(DefineError), Write(Erroreqn), Write(Cond))
        self.wait()
        self.remove(DefineError, Cond)
        average = Tex("Average probability of Error", color = ORANGE).next_to(Capacity, DOWN, buff = 0.2).shift(RIGHT*2)
        averageprob = Tex(r"$\bar{P}_n(e)$ = $\frac{1}{M}\underset{w}{\sum}\lambda(w)$", tex_template = newTemplate,)
        self.play(Transform(Error, average), Transform(Erroreqn, averageprob), run_time = 2)
        self.remove(average, averageprob, Error, Erroreqn)
        maximalstart = Tex("Thus maximal probability of error for the (M,n) code is defined as").next_to(Capacity, DOWN, buff = 0.2).shift(RIGHT*4.5).scale(0.9)
        maximal = Tex(r"$\lambda_n = \underset{w\epsilon{M}}{max}$ $\lambda(w)$",tex_template = newTemplate)
        self.play(Write(maximal), Write(maximalstart))
        self.wait()
        self.remove(maximal, maximalstart)
        TopicRate= Tex("RATE", color = ORANGE).next_to(Capacity, DOWN, buff = 0.2)
        Rate = Tex(r"The rate R of an (M,n) code is defined by \[R = \frac{1}{n} logM\]").next_to(TopicRate, DOWN, buff = 0.2).shift(RIGHT*4)
        self.play(Write(TopicRate), Write(Rate))
        self.wait()
        self.remove(Rate)
        achieve = Tex(r"The rate R is said to be achievable by a relay channel if, for any $\epsilon$ $>$ 0 and for all n sufficiently large, there exists an (M,n) code with \[M\ge2^{nR}\]").next_to(TopicRate, DOWN, buff = 0.2).shift(RIGHT*4.5).scale(0.8)
        self.play(Write(achieve))
        self.wait()
        such = Tex(r"such that $\lambda_n < \epsilon$. The capacity C of the relay channel is the supremum of the set of achievable rates.").next_to(achieve, DOWN, buff = 0.6).scale(0.8)
        self.play(Write(such))
        self.wait()
        self.play(FadeOut(Capacity,TopicRate,achieve,such))
        self.play(Write(Degr))
        self.play(Degr.animate.next_to(Topic,DOWN,buff=0.1).scale(0.85).shift(LEFT))
        text = Tex(r"$\textit{Definition}$: The Relay Channel $(\mathscr{X}_1 \times \mathscr{X}_2 ,p(y,y_1|x_1,x_2),\mathscr{Y} \times \mathscr{Y}_1)$",tex_template = myTemplate).scale(0.9).to_edge(LEFT, buff = 0.5).shift(UP*2)
        definition = Tex(r"is said to be $\textit{degraded}$ if $p(y,y_1|x_1,x_2)$ can be written in the form",tex_template = myTemplate).scale(0.9).next_to(text, DOWN ,buff = 0.2)
        formula = Tex(r"$p(y,y_1|x_1,x_2) = p(y_1|x_1,x_2) p(y|y_1,x_2)$",tex_template = myTemplate).next_to(definition,DOWN,buff= 0.2)
        self.play(VGroup(text,definition,formula).animate.set_color(ORANGE))
        formula2 = Tex(r"$\because$ Using chain rule we wan write", tex_template = myTemplate).next_to(formula,DOWN,buff= 0.5).shift(LEFT*3)
        formula3 = Tex(r"$p(y,y_1|x_1,x_2) = p(y|x_1,x_2,y_1) p(y|y_1,x_2)$", tex_template = myTemplate).next_to(formula2,DOWN,buff = 0.2).shift(RIGHT*3)
        self.play(Write(formula2))
        self.play(Write(formula3))
        formula4 = Tex(r"$\therefore$ A relay channel is degraded if", tex_template = myTemplate).next_to(formula3,DOWN,buff = 0.2).shift(LEFT*3)
        formula5 = Tex(r"$p(y|x_1,x_2,y_1) = p(y|y_1,x_2)$", tex_template = myTemplate).next_to(formula4,DOWN,buff = 0.2).shift(RIGHT*3)
        self.play(Write(formula4))
        self.play(Write(formula5))
        self.play(FadeOut(formula2,formula3))
        self.play(VGroup(formula4,formula5).animate.next_to(formula,DOWN,buff = 0.2).shift(LEFT*2))
        formula6 = Tex(r"$i.e. \quad X_1 \rightarrow (X_2,X_1) \rightarrow$ Y forms a Markov Chain", tex_template = myTemplate).next_to(formula5,DOWN,buff= 0.5)
        self.play(Write(formula6))
        self.play(FadeOut(text,definition,formula,formula4,formula5,formula6,Degr))
        text = Tex(r"$\textit{Theorem 2}$: The Capacity $C_0$ of the").to_edge(LEFT, buff = 0.5).shift(UP*2).scale(0.8)
        rev = Tex("reversely degraded relay channel").scale(0.8).next_to(text,RIGHT)
        rever = Tex("Reversely Degraded Relay Channel").scale(0.8).next_to(text,RIGHT)
        last = Tex("is given by :").scale(0.8).next_to(text, DOWN, buff = 0.2).shift(LEFT*0.5)
        equation = Tex(r"$C_0 = \underset{x_2 \in {X}}{\max}$ $\underset{p(x_1)}{\max} \{I(X_1;Y|x_2)\}$",tex_template = newTemplate).next_to(last, DOWN, buff = 0.2).shift(3*RIGHT)
        self.play(FadeIn(text, rev, last, equation))
        self.play(Transform(rev, rever))
        self.play(FadeOut(last, text, equation,rev))
        self.play(rever.animate.next_to(Topic, DOWN, buff = 0.4).set_color(YELLOW))
        Def = Tex(r"\textit{Definition :} The relay channel ($\mathscr{X}_1$ $\times$ $\mathscr{X}_2$ ,$p(y,y_1|x_1,x_2)$,$\mathscr{Y}$ $\times$ $\mathscr{Y}_1)$ is \textit{reversely degraded} if $p(y, y_1|x_1, x_2)$ can be written in the form \[p(y,y_1|x_1, x_2) = p(y|x_1,x_2)p(y_1|y,x_2).\]",tex_template = myTemplate).next_to(rever, DOWN, buff = 0.4).scale(0.8).shift(RIGHT*3)
        self.play(Write(Def))
        self.play(FadeOut(Def),FadeOut(rever))
        self.wait()
        
        # Gausian Degraded Relay Channel
        name = MathTex("Degradfds", color=BLACK).scale(0.8)
        box = SurroundingRectangle(
            name, color=BLACK, fill_opacity=0.5, fill_color= BLACK, buff=0.2)
        relayEncoder = Tex("Relay Encoder",color=boxTextColor).scale(0.8).next_to(box, UP, buff=1.5)
        boxRelay = always_redraw(lambda: SurroundingRectangle(
            relayEncoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        Encoder = Tex("+", color = boxTextColor).scale(0.8).next_to(box, LEFT,  buff = 2)
        Decoder = Tex("+", color = boxTextColor).scale(0.8).next_to(box, RIGHT, buff = 2)
        EncoderBox = always_redraw(lambda: SurroundingRectangle(
            Encoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        DecoderBox = always_redraw(lambda: SurroundingRectangle(
            Decoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        arrow1 = Arrow(start = box.get_top()-UP*0.4, end = boxRelay.get_bottom(), buff = 0.1).shift(LEFT*1.3)
        arrow2 = Arrow(start = boxRelay.get_right(), end = DecoderBox.get_top())
        arrow3 = Arrow(start= EncoderBox.get_right(), end = box.get_left())
        arrow4 = Arrow(start = arrow3.get_right(), end = DecoderBox.get_left(), buff = 0.1)
        x2 = MathTex("X_2", color = BLUE).scale(0.75).next_to(relayEncoder, RIGHT).shift(RIGHT*0.3).shift(DOWN*1)
        y1 = MathTex("Y_1", color = BLUE).scale(0.75).next_to(arrow1,RIGHT*0.3)
        degraded = Tex("DEGRADED", color = YELLOW).scale(0.75).next_to(arrow4, DOWN*1.5)
        W = Tex("$X_1$", color = BLUE).scale(0.75).next_to(EncoderBox, LEFT, buff = 1)
        W1 = MathTex("Y", color = BLUE).scale(0.75).next_to(DecoderBox, RIGHT, buff  = 1)
        arrow5 = Arrow(start = W.get_right(), end = EncoderBox.get_left(), buff = 0.1)
        arrow6 = Arrow(start = DecoderBox.get_right(), end = W1.get_left(), buff = 0.1)
        powerp1 = Tex("Power $P_1$",color = YELLOW).scale(0.75).next_to(W,DOWN*1.5)
        powerp2 = Tex("Power $P_2$",color = YELLOW).scale(0.75).next_to(relayEncoder,DOWN*1.5).shift(RIGHT)
        z1 = Tex(r"$Z_1 \sim N(0,N_1)$",color = YELLOW,tex_template = myTemplate).scale(0.75).next_to(EncoderBox,UP*4.5)
        arrow7 = Arrow(start =  z1.get_bottom(), end = EncoderBox.get_top())
        z2 = Tex(r"$Z_2 \sim N(0,N_2)$",color = YELLOW,tex_template = myTemplate).scale(0.75).next_to(DecoderBox,UP*4.5)
        arrow8 = Arrow(start =  z2.get_bottom(), end = DecoderBox.get_top())
        n1 = Tex("$N = N_1 + N_2$",color = YELLOW).scale(0.75).next_to(W1,DOWN*1.5)
        denotedBy = Tex(r"\[C^{*}= \underset{0<\alpha<1}{max}min\{C(\frac{P_1+P_2+2\sqrt{\bar{\alpha}P_1P_2}}{N})C(\frac{\alpha P_1}{N_1})\}\]",tex_template = newTemplate).next_to(box,DOWN,buff= 1)
        # self.add(W,W1,EncoderBox,Encoder,arrow5,box,name,arrow3,boxRelay,relayEncoder,arrow1,y1,arrow2,x2,DecoderBox,Decoder,arrow4,degraded,arrow6,powerp1,n1,powerp2,z1,arrow7,z2,arrow8)
        self.play(Write(W))
        self.play(Write(W1))
        self.play(Create(EncoderBox),Create(Encoder))
        self.play(Create(arrow5))
        self.play(Create(box),Create(name))
        self.play(Create(arrow3))
        self.play(Create(boxRelay),Create(relayEncoder))
        self.play(Create(arrow1),Write(y1),Create(arrow4))
        self.play(Create(arrow2),Write(x2))
        self.play(Create(DecoderBox),Write(Decoder))
        self.play(Create(arrow6))
        self.play(FadeIn(powerp1),FadeIn(powerp2))
        self.play(FadeIn(z1),Create(arrow7),FadeIn(z2),Create(arrow8))
        self.play(FadeIn(n1))
        self.play(FadeIn(degraded))
        self.play(FadeIn(denotedBy))
        self.wait()
        self.play(FadeOut(denotedBy,z1,arrow7,z2,arrow8,powerp1,powerp2,arrow6,arrow4,DecoderBox,Decoder,arrow2,x2,arrow1,y1,boxRelay,relayEncoder,arrow3,box,name,arrow5,EncoderBox,Encoder,W1,W,degraded,n1))
        self.wait()

        # proof
        # general gaussian relay channel
        Topic2 = Tex("General Gaussian Relay Channel", color = ORANGE).next_to(Topic,DOWN)
        self.play(Write(Topic2))
        fillColor = BLUE
        boxTextColor = YELLOW
        
        name = MathTex("..........", color=BLACK).scale(0.8).next_to(Topic2, DOWN, buff = 4).shift(RIGHT*4)
        box = SurroundingRectangle(
            name, color=BLACK, fill_opacity=0.5, fill_color= BLACK, buff=0.2)
        relayEncoder = Tex("Relay Encoder",color=boxTextColor).scale(0.8).next_to(box, UP, buff=1.5)
        boxRelay = always_redraw(lambda: SurroundingRectangle(
            relayEncoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        Encoder = Tex("+", color = boxTextColor).scale(0.8).next_to(boxRelay, LEFT,  buff = 2)
        Decoder = Tex("+", color = boxTextColor).scale(0.8).next_to(box, RIGHT, buff = 2)
        EncoderBox = always_redraw(lambda: SurroundingRectangle(
            Encoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        DecoderBox = always_redraw(lambda: SurroundingRectangle(
            Decoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        arrow1 = Arrow(start = box.get_top()-UP*0.4, end = boxRelay.get_bottom(), buff = 0.1).shift(LEFT*1.3)
        arrow2 = Arrow(start = boxRelay.get_right(), end = DecoderBox.get_top())
        arrow3 = Arrow(start= EncoderBox.get_right(), end = boxRelay.get_left())
        arrow4 = Arrow(start = arrow3.get_right(), end = DecoderBox.get_left(), buff = 0.1)
        x2 = MathTex("X_2", color = BLUE).scale(0.75).next_to(relayEncoder, RIGHT).shift(RIGHT*0.3).shift(DOWN*1)
        y1 = MathTex("Y_1", color = BLUE).scale(0.75).next_to(arrow3,UP)
        # x1 = MathTex("X_1", color = BLUE).scale(0.75).next_to(arrow3, DOWN).shift(DOWN*2)
        degraded = Tex("DEGRADED", color = YELLOW).scale(0.75).next_to(arrow4, DOWN*1.5)
        W = Tex("$X_1$", color = BLUE).scale(0.75).next_to(EncoderBox, LEFT, buff = 1).shift(DOWN*2)
        W1 = MathTex("Y", color = BLUE).scale(0.75).next_to(DecoderBox, RIGHT, buff  = 1)
        arrow5 = Arrow(start = W.get_right(), end = DecoderBox.get_left(), buff = 0.1)
        arrow6 = Arrow(start = DecoderBox.get_right(), end = W1.get_left(), buff = 0.1)
        arrow9 = Arrow(start = W.get_right(), end = EncoderBox.get_left(), buff = 0.1)
        powerp1 = Tex("Power P",color = YELLOW).scale(0.75).next_to(W,DOWN*1.5)
        powerp2 = Tex("Power $P_1$",color = YELLOW).scale(0.75).next_to(relayEncoder,DOWN*1.5).shift(RIGHT)
        z1 = Tex(r"$Z_1 \sim N(0,N_1)$",color = YELLOW,tex_template = myTemplate).scale(0.75).next_to(EncoderBox,UP*4.5)
        arrow7 = Arrow(start =  z1.get_bottom(), end = EncoderBox.get_top())
        z2 = Tex(r"$Z \sim N(0,N)$",color = YELLOW,tex_template = myTemplate).scale(0.75).next_to(DecoderBox,UP*4.5)
        arrow8 = Arrow(start =  z2.get_bottom(), end = DecoderBox.get_top())
        n1 = Tex("$N = N_1 + N_2$",color = YELLOW).scale(0.75).next_to(W1,DOWN*1.5)
        denotedBy = Tex(r"$(\mathscr{X}_1 \times \mathscr{X}_2 ,p(y,y_1|x_1,x_2),\mathscr{Y} \times \mathscr{Y}_1)$",tex_template = myTemplate).next_to(box,DOWN,buff= 1)
        # self.add(W,W1,arrow9,EncoderBox,Encoder,arrow5,box,name,arrow3,boxRelay,relayEncoder,y1,arrow2,x2,DecoderBox,Decoder,arrow6,powerp1,powerp2,z1,arrow7,z2,arrow8)
        self.play(Write(W),Write(W1))
        self.play(Create(EncoderBox),Create(Encoder))
        self.play(Create(arrow9))
        self.play(Create(name),Create(box))
        self.play(Create(boxRelay),Create(relayEncoder))
        self.play(Create(arrow3),Create(y1))
        self.play(Create(DecoderBox),Create(Decoder))
        self.play(Create(arrow5),Create(arrow2),Create(x2))
        self.play(Create(arrow6))
        self.play(Create(arrow7),Create(z1),Create(z2),Create(arrow8))
        self.play(Create(powerp1),Create(powerp2))
        self.wait()
        self.play(FadeOut(z1,arrow9,arrow7,z2,arrow8,powerp1,powerp2,arrow6,DecoderBox,Decoder,arrow2,x2,y1,boxRelay,relayEncoder,arrow3,box,name,arrow5,EncoderBox,n1, Encoder,W1,W))
        Theorem = Tex(r"\textit{Theorem :} Let $(\mathscr{X}_1 \times \mathscr{X}_2, p(y,y_1|x_1,x_2),\mathscr{Y} \times \mathscr{Y}_1)$ be any discrete memoryless relay channel. Then the rate $R_1^{}$ is achievable, where \[R_1^{} = supI(X_1;Y,\hat{Y}_1|X_2)\]", tex_template = myTemplate).scale(0.8).next_to(Topic2, DOWN, buff = 0.2).shift(RIGHT*3)
        self.play(Write(Theorem))
        Next = Tex(r"subject to constraint \[I(X_2;Y) \ge I(Y_1; \hat{Y}_1|X_2,Y)\]", tex_template = myTemplate).scale(0.8).next_to(Theorem, DOWN, buff = 0.2)
        self.play(Write(Next))
        last = Tex(r"where the supremum is taken over all joint distributions on $\mathscr{X}_1 \times \mathscr{X}_2 \times \mathscr{Y} \times \mathscr{Y}_1 \times \mathscr{\hat{Y}}_1$ of the form \[p(x_1,x_2,y,y_1,\hat{y}_1) = p(x_1)p(x_2)p(y,y_1|x_1,x_2)p(\hat{y}_1|y_1,x_2)\]", tex_template = myTemplate).scale(0.8).next_to(Next, DOWN, buff = 0.2)
        self.play(Write(last))
        closing = Tex(r"and $\hat{Y}_1$ has a finite region.").scale(0.8).next_to(last, DOWN, buff = 0.2)
        self.play(Write(closing))
        self.wait()
        self.play(FadeOut(Theorem,Next,last,closing,Topic2))

        # outline of proof
        outline = Tex(r"\textit{Outline of Proof :} A block Markov encoding is used At the end of any block $i,$ the $x_2$ information is used to resolve the uncertainty of the receiver about $w_{i-1}.$ ").scale(0.8)#.next_to(rever, DOWN, buff = 0.4).scale(0.8).shift(RIGHT*3)
        self.play(Write(outline))
        self.wait()
        self.play(FadeOut(outline))
        DefTopic = Tex(r"\epsilon - TYPICALITY", color = ORANGE).next_to(Topic, DOWN, buff = 0.1).shift(LEFT)
        Def = Tex(r"\textit{Definition :} The set $A_{\epsilon}$ of $\epsilon -typical$ $n$-sequences ($x^{(1)},x^{(2)},...,x^{(k)}$) is defined by $A_{\epsilon}$($X^{(1)},X^{(2)},...,X^{(k)}$) = $A_{\epsilon}$ = \{($\textbf{x}^{(1)},\textbf{x}^{(2)},...,\textbf{x}^{(k)}$):$$\left|\frac{1}{n} N ( x^{(1)},x^{(2)},...,x^{(k)};\textbf{x}^{(1)},\textbf{x}^{(2)},...,\textbf{x}^{(k)}) - p(x^{(1)},x^{(2)},...,x^{(k)} )\right| < $$ $\epsilon ||\mathscr{X}^{(1)} \times \mathscr{X}^{(2)} \times...\times \mathscr{X}^{(k)}||,$ for $(x^{(1)},x^{(2)},...,x^{(k)}) \in \mathscr{X}^{(1)} \times \mathscr{X}^{(2)} \times...\times \mathscr{X}^{(k)}\}$",tex_template = myTemplate).scale(0.8)#.next_to(rever, DOWN, buff = 0.4).scale(0.8).shift(RIGHT*3)
        self.play(Write(DefTopic))
        self.play(Write(Def))
        self.wait()
        self.play(FadeOut(Def,DefTopic))

        EncodingTopic = Tex(r"Encoding", color = PURPLE).next_to(Topic2, DOWN, buff = 0.2).shift(LEFT)
        self.play(Write(EncodingTopic))
        Encoding = Tex(r"Let $w_i$ be the message to be sent in block i, and assume that (\textbf{$\hat{Y}1$}($z{i-1}$|$s_{i-1}$),\textbf{$Y_1$}(i-1),\textbf{$x_2$}($s_{i-1}$)) are jointly $\epsilon$ -typical, and that $Z_{i-1}$ $\epsilon$ $S_{s_{i}}$, where $S_{s}$ is formed by partioning the set \{1,2,...,$2^{n\hat{R}}$\}, into $2^{nR_0}$ cells. Then the codeword pair(\textbf{$x_1$}($w_i$),\textbf{$x_2$}($s_i$)), will be transmitted in block i.",tex_template = myTemplate).scale(0.8).next_to(EncodingTopic, DOWN, buff = 0.5).shift(RIGHT*4)
        self.play(Write(Encoding))
        self.remove(Encoding)
        DecodingTopic = Tex(r"Decoding", color = PURPLE).next_to(Topic2, DOWN, buff = 0.2).shift(LEFT)
        self.play(ReplacementTransform(EncodingTopic, DecodingTopic))
        Decoding = Tex(r"The decoding of the output signal can be broken down into some channels such that \[R_0 < I(X_2,Y)\] \[\hat{R}_1<I(\hat{Y}_1;Y|X_2) + R_0\] \[R_1<I(X_1;Y,\hat{Y}_1|X_2)\] \[\hat{R} > I(\hat{Y}_1;Y_1|X_2)\] These equations collapses to yield ").scale(0.8).next_to(DecodingTopic, DOWN, buff = 0.5).shift(RIGHT*4)
        self.play(Write(Decoding))
        Decodingnext = Tex(r"\[I(X_2;Y) \ge I( \hat{Y}_1,Y_1|X_2,Y).\] Thus we see that the rate $R^{*}_1$ is achievable. Here,\[R_1^{*} = supI(X_1;Y,\hat{Y}_1|X_2)\]").scale(0.8).next_to(DecodingTopic, DOWN, buff = 0.5).shift(RIGHT*5)
        self.play(Transform(Decoding, Decodingnext))
        self.wait()
        self.play(FadeOut(Decoding,Decodingnext,DecodingTopic, EncodingTopic))

        
        # Conclusion
        fillColor = BLUE
        boxTextColor = YELLOW
        myTemplate = TexTemplate()
        myTemplate.add_to_preamble(r"\usepackage{mathrsfs}")
        newTemplate = TexTemplate()
        newTemplate.add_to_preamble(r"\usepackage{amsmath}")
        Conc = Tex("Conclusion", color = YELLOW).to_edge(UL, buff = 0.2).next_to(Topic,DOWN).shift(LEFT*2.3)
        Start = Tex("The paper mainly focusses on building theory regarding capacity for different relay channels we, started with finding the capacity for Degraded Relay Channel").scale(0.8).next_to(Conc, DOWN, buff = 0.5).shift(RIGHT*6)
        self.play(Write(Conc))
        self.play(Write(Start))
        name = MathTex("p(y,y_1|x_1,x_2)", color=boxTextColor).scale(0.8).next_to(Start, DOWN, buff = 3.5)
        box = always_redraw(lambda:SurroundingRectangle(
            name, color=BLACK, fill_opacity=0.5, fill_color=fillColor, buff=0.2))
        relayEncoder = Tex("Relay Encoder",color=boxTextColor).scale(0.8).next_to(box, UP, buff=1)
        boxRelay = always_redraw(lambda: SurroundingRectangle(
            relayEncoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        Encoder = Tex("Encoder", color = boxTextColor).scale(0.8).next_to(box, LEFT,  buff = 2)
        Decoder = Tex("Decoder", color = boxTextColor).scale(0.8).next_to(box, RIGHT, buff = 2)
        EncoderBox = always_redraw(lambda: SurroundingRectangle(
            Encoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        DecoderBox = always_redraw(lambda: SurroundingRectangle(
            Decoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        arrow1 = Arrow(start = box.get_top(), end = boxRelay.get_bottom(), buff = 0.1).shift(LEFT*0.8)
        arrow2 = Arrow(start = boxRelay.get_bottom(), end = box.get_top(), buff = 0.1).shift(RIGHT*0.8)
        arrow3 = Arrow(start= EncoderBox.get_right(), end = box.get_left(), buff = 0.1)
        arrow4 = Arrow(start = box.get_right(), end = DecoderBox.get_left(), buff = 0.1)
        x2 = MathTex("X_2", color = BLUE).scale(0.75).next_to(arrow2, RIGHT)
        y1 = MathTex("Y_1", color = BLUE).scale(0.75).next_to(arrow1, LEFT)
        x1 = MathTex("X_1", color = BLUE).scale(0.75).next_to(arrow3, UP)
        y = MathTex("Y", color = BLUE).scale(0.75).next_to(arrow4, UP)
        W = Tex("W", color = BLUE).scale(0.75).next_to(EncoderBox, LEFT, buff = 1)
        W1 = MathTex("\hat{W}", color = BLUE).scale(0.75).next_to(DecoderBox, RIGHT, buff  = 1)
        arrow5 = Arrow(start = W.get_right(), end = EncoderBox.get_left(), buff = 0.1)
        arrow6 = Arrow(start = DecoderBox.get_right(), end = W1.get_left(), buff = 0.1)
        denotedBy = Tex(r"$(\mathscr{X}_1 \times \mathscr{X}_2 ,p(y,y_1|x_1,x_2),\mathscr{Y} \times \mathscr{Y}_1)$",tex_template = myTemplate).next_to(box,DOWN,buff= 1)
        self.add(W, W1, EncoderBox, Encoder, Decoder, DecoderBox, arrow5)
        self.add(box, name, arrow3, x1, boxRelay, relayEncoder, arrow1, y1)
        self.add(arrow2, x2)
        self.add(arrow4, y, arrow6, denotedBy)
        self.wait()
        equation = Tex(r"and it turned out to be C = $\underset{p(x_1|x_2)}{sup}$ min\{I($X_1$,$X_2$;Y),I($X_1;Y_1|X_2$)\}",tex_template = newTemplate,).scale(0.8).next_to(Conc, DOWN, buff = 0.5).shift(RIGHT*6)
        self.play(ReplacementTransform(Start, equation))
        self.wait()

        equation2 = Tex(r"and moved on to capacity for the reversely degraded channel and found it out to be $C_0 = \underset{x_2 \in {X}}{\max}$ $\underset{p(x_1)}{\max} \{I(X_1;Y|x_2)\}$",  tex_template = newTemplate).scale(0.8).next_to(Conc, DOWN, buff = 0.5).shift(RIGHT*6)
        self.play(ReplacementTransform(equation, equation2))
        self.wait()
        self.play(FadeOut(denotedBy,arrow6,arrow4,y,DecoderBox,Decoder,arrow2,x2,arrow1,y1,boxRelay,relayEncoder,arrow3,x1,box,name,arrow5,EncoderBox,Encoder,W1,W))
        
        name = MathTex("Degradfds", color=BLACK).scale(0.8).next_to(Start, DOWN, buff = 4.5)
        box = SurroundingRectangle(
            name, color=BLACK, fill_opacity=0.5, fill_color= BLACK, buff=0.2)
        relayEncoder = Tex("Relay Encoder",color=boxTextColor).scale(0.8).next_to(box, UP, buff=1)
        boxRelay = always_redraw(lambda: SurroundingRectangle(
            relayEncoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        Encoder = Tex("+", color = boxTextColor).scale(0.8).next_to(box, LEFT,  buff = 2)
        Decoder = Tex("+", color = boxTextColor).scale(0.8).next_to(box, RIGHT, buff = 2)
        EncoderBox = always_redraw(lambda: SurroundingRectangle(
            Encoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        DecoderBox = always_redraw(lambda: SurroundingRectangle(
            Decoder,color = BLACK, fill_opacity=0.5, fill_color= fillColor, buff=0.2
        ))
        arrow1 = Arrow(start = box.get_top()-UP*0.4, end = boxRelay.get_bottom(), buff = 0.1).shift(LEFT*1.3)
        arrow2 = Arrow(start = boxRelay.get_right(), end = DecoderBox.get_top())
        arrow3 = Arrow(start= EncoderBox.get_right(), end = box.get_left())
        arrow4 = Arrow(start = arrow3.get_right(), end = DecoderBox.get_left(), buff = 0.1)
        x2 = MathTex("X_2", color = BLUE).scale(0.75).next_to(relayEncoder, RIGHT).shift(RIGHT*0.3).shift(DOWN*1)
        y1 = MathTex("Y_1", color = BLUE).scale(0.75).next_to(arrow1,RIGHT*0.3)
        degraded = Tex("DEGRADED", color = YELLOW).scale(0.75).next_to(arrow4, DOWN*1.5)
        W = Tex("$X_1$", color = BLUE).scale(0.75).next_to(EncoderBox, LEFT, buff = 1)
        W1 = MathTex("Y", color = BLUE).scale(0.75).next_to(DecoderBox, RIGHT, buff  = 1)
        arrow5 = Arrow(start = W.get_right(), end = EncoderBox.get_left(), buff = 0.1)
        arrow6 = Arrow(start = DecoderBox.get_right(), end = W1.get_left(), buff = 0.1)
        powerp1 = Tex("Power $P_1$",color = YELLOW).scale(0.75).next_to(W,DOWN*1.5)
        powerp2 = Tex("Power $P_2$",color = YELLOW).scale(0.75).next_to(relayEncoder,DOWN*1.5).shift(RIGHT)
        z1 = Tex(r"$Z_1 \sim N(0,N_1)$",color = YELLOW,tex_template = myTemplate).scale(0.75).next_to(EncoderBox,UP*4.5)
        arrow7 = Arrow(start =  z1.get_bottom(), end = EncoderBox.get_top())
        z2 = Tex(r"$Z_2 \sim N(0,N_2)$",color = YELLOW,tex_template = myTemplate).scale(0.75).next_to(DecoderBox,UP*4.5)
        arrow8 = Arrow(start =  z2.get_bottom(), end = DecoderBox.get_top())
        n1 = Tex("$N = N_1 + N_2$",color = YELLOW).scale(0.75).next_to(W1,DOWN*1.5)
        denotedBy = Tex(r"$(\mathscr{X}_1 \times \mathscr{X}_2 ,p(y,y_1|x_1,x_2),\mathscr{Y} \times \mathscr{Y}_1)$",tex_template = myTemplate).next_to(box,DOWN,buff= 1)
        self.add(W,W1,EncoderBox,Encoder,arrow5,box,name,arrow3,boxRelay,relayEncoder,arrow1,y1,arrow2,x2,DecoderBox,Decoder,arrow4,degraded,arrow6,powerp1,n1,powerp2,z1,arrow7,z2,arrow8)
        equation3 = Tex(r"then we added the Additive Gaussian White Noise to the degraded case and the capacity in terms of respective power, \[C^{*}= \underset{0<\alpha<1}{max}min\{C(\frac{P_1+P_2+2\sqrt{\bar{\alpha}P_1P_2}}{N})C(\frac{\alpha P_1}{N_1})\}\] ", tex_template = newTemplate).scale(0.7).next_to(Conc, DOWN, buff = 0.3).shift(RIGHT*6)
        self.play(ReplacementTransform(equation2, equation3))
        self.wait()
        self.play(FadeOut(denotedBy,z1,arrow7,z2,arrow8,powerp1,powerp2,arrow6,arrow4,DecoderBox,Decoder,arrow2,x2,arrow1,y1,boxRelay,relayEncoder,arrow3,box,name,arrow5,EncoderBox,n1, Encoder,W1,W,degraded))
        hence = Tex(r"And hence the capacity of relay channel can be found out using the simpler version which may be employed for uses of relay channel in general.").scale(0.7).next_to(Conc, DOWN, buff = 0.3).shift(RIGHT*6)
        self.play(ReplacementTransform(equation3, hence))
        self.wait()
        Def = Tex(r"\textit{Definition :} The relay channel ($\mathscr{X}_1$ $\times$ $\mathscr{X}_2$ ,$p(y,y_1|x_1,x_2)$,$\mathscr{Y}$ $\times$ $\mathscr{Y}_1)$ is \textit{reversely degraded} if $p(y, y_1|x_1, x_2)$ can be written in the form \[p(y,y_1|x_1, x_2) = p(y|x_1,x_2)p(y_1|y,x_2).\]",tex_template = myTemplate).next_to(rever, DOWN, buff = 0.4).scale(0.8).shift(RIGHT*3)
        
        self.wait()